// Package etag provides functions for parsing and generating globally unique
// ETags from a UUID and updated-at timestamp.
//
// Tags generated by this package are designed to support optimistic concurrency
// control at the web server and database levels without requiring a full hash
// of the resource or any additional data to be persisted.
//
// For Postgres, the resolution of the timestamp field is 1 microsecond, which
// is sufficient for all expected workloads.
//
// All tags generated by this package are considered strong ETags, since
// identical tags necessarily correspond to identical resources.
package etag

import (
	"fmt"
	"strings"
	"time"

	"github.com/brianvoe/gofakeit/v6"

	"github.com/google/uuid"
)

const (
	eTagSeparator = ";"
	eTagFormat    = `"00000000-0000-0000-0000-000000000000;2006-01-02T15:04:05.999999999Z07:00"`
)

// ETag uniquely identifies a version of an entity.
type ETag struct {
	id        uuid.UUID
	updatedAt time.Time
}

func New(id uuid.UUID, updatedAt time.Time) ETag {
	return ETag{
		id:        id,
		updatedAt: updatedAt,
	}
}

// ParseETagError represents any failure to parse an ETag from a string.
type ParseETagError struct {
	RawETag string
	Cause   error
}

func (e *ParseETagError) Error() string {
	return fmt.Sprintf("ETag %s was not in the expected format %s: %s", e.RawETag, eTagFormat, e.Cause)
}

// Parse parses an ETag from a string.
func Parse(raw string) (ETag, error) {
	if !strings.HasPrefix(raw, `"`) || !strings.HasSuffix(raw, `"`) {
		return ETag{}, &ParseETagError{
			RawETag: raw,
			Cause: fmt.Errorf(
				"expected double-quoted string, got %s",
				raw,
			),
		}
	}

	unquoted := strings.Trim(raw, `"`)
	components := strings.Split(unquoted, eTagSeparator)
	if len(components) != 2 {
		return ETag{}, &ParseETagError{
			RawETag: raw,
			Cause: fmt.Errorf(
				"expected %d components with separtor %q, got %d",
				2,
				eTagSeparator,
				len(components),
			),
		}
	}

	id, err := uuid.Parse(components[0])
	if err != nil {
		return ETag{}, &ParseETagError{RawETag: raw, Cause: err}
	}

	updatedAt, err := time.Parse(time.RFC3339Nano, components[1])
	if err != nil {
		return ETag{}, &ParseETagError{RawETag: raw, Cause: err}
	}

	return ETag{
		id:        id,
		updatedAt: updatedAt,
	}, nil
}

func (e ETag) ID() uuid.UUID {
	return e.id
}

func (e ETag) UpdatedAt() time.Time {
	return e.updatedAt
}

func (e ETag) String() string {
	var builder strings.Builder
	builder.WriteByte('"')
	builder.WriteString(e.id.String())
	builder.WriteString(eTagSeparator)
	builder.WriteString(e.updatedAt.Format(time.RFC3339Nano))
	builder.WriteByte('"')
	return builder.String()
}

const yearSeconds = 31_536_000

// Random returns an ETag with a random ID and a timestamp within the
// last year.
func Random() ETag {
	now := time.Now()
	lastYear := now.Add(-yearSeconds * time.Second)
	return ETag{
		id:        uuid.New(),
		updatedAt: gofakeit.DateRange(lastYear, now),
	}
}
